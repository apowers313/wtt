const { MockSetup, TestAssertions, ConsoleCapture } = require('../../helpers');
const { createCommand } = require('../../../commands/create');

describe('create command unit tests (refactored)', () => {
  let mocks;

  beforeEach(() => {
    // Create all mocks with one helper
    mocks = MockSetup.createMockEnvironment({
      config: {
        worktreeDir: '.worktrees',
        mainBranch: 'main'
      },
      inquirerAnswers: {
        confirmCreate: true
      }
    });
    
    // Clear all mock calls
    jest.clearAllMocks();
  });

  describe('basic functionality', () => {
    test('creates worktree with correct parameters', async () => {
      const result = await createCommand('feature-branch', {}, mocks);
      
      expect(result.success).toBe(true);
      
      // Verify git operations called correctly
      expect(mocks.gitOps.createWorktree).toHaveBeenCalledWith(
        'feature-branch',
        expect.objectContaining({
          baseBranch: 'main',
          path: '.worktrees/wt-feature-branch'
        })
      );
      
      // Verify port assignment
      expect(mocks.portManager.assignPorts).toHaveBeenCalledWith('wt-feature-branch');
    });

    test('handles existing branch gracefully', async () => {
      mocks.gitOps.getBranches.mockResolvedValue(['main', 'feature-branch']);
      
      const result = await createCommand('feature-branch', {}, mocks);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('already exists');
    });

    test('validates branch name', async () => {
      const invalidNames = ['main', '-invalid', 'feature//', ''];
      
      for (const name of invalidNames) {
        const result = await createCommand(name, {}, mocks);
        expect(result.success).toBe(false);
        expect(result.error).toBeDefined();
      }
    });
  });

  describe('port management', () => {
    test('assigns ports for each service', async () => {
      const mockPorts = { vite: 3010, storybook: 6016, custom: 8090 };
      mocks.portManager.assignPorts.mockResolvedValue(mockPorts);
      
      const result = await createCommand('feature', {}, mocks);
      
      expect(result.success).toBe(true);
      expect(result.ports).toEqual(mockPorts);
      expect(mocks.portManager.savePortMap).toHaveBeenCalled();
    });

    test('handles port assignment failure', async () => {
      mocks.portManager.assignPorts.mockRejectedValue(new Error('No ports available'));
      
      const result = await createCommand('feature', {}, mocks);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('port');
    });
  });

  describe('options handling', () => {
    test('creates from specific branch', async () => {
      mocks.gitOps.getBranches.mockResolvedValue(['main', 'develop']);
      
      const result = await createCommand('feature', { from: 'develop' }, mocks);
      
      expect(result.success).toBe(true);
      expect(mocks.gitOps.createWorktree).toHaveBeenCalledWith(
        'feature',
        expect.objectContaining({ baseBranch: 'develop' })
      );
    });

    test('respects no-switch option', async () => {
      const result = await createCommand('feature', { noSwitch: true }, mocks);
      
      expect(result.success).toBe(true);
      expect(result.switched).toBe(false);
    });

    test('handles force option for existing worktree', async () => {
      mocks.gitOps.getWorktrees.mockResolvedValue([
        { branch: 'feature', path: '.worktrees/wt-feature' }
      ]);
      
      const result = await createCommand('feature', { force: true }, mocks);
      
      expect(mocks.gitOps.removeWorktree).toHaveBeenCalledWith('feature');
      expect(mocks.gitOps.createWorktree).toHaveBeenCalled();
    });
  });

  describe('error scenarios', () => {
    test('handles uncommitted changes', async () => {
      mocks.gitOps.hasUncommittedChanges.mockResolvedValue(true);
      
      const result = await createCommand('feature', {}, mocks);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('uncommitted changes');
    });

    test('handles git operation failures', async () => {
      mocks.gitOps.createWorktree.mockRejectedValue(new Error('Git error'));
      
      const result = await createCommand('feature', {}, mocks);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Git error');
    });

    test('handles missing base branch', async () => {
      mocks.gitOps.getBranches.mockResolvedValue(['main']);
      
      const result = await createCommand('feature', { from: 'nonexistent' }, mocks);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('nonexistent');
    });
  });

  describe('console output', () => {
    test('produces correct output on success', async () => {
      const capture = new ConsoleCapture();
      capture.start();
      
      await createCommand('feature', {}, { ...mocks, output: console });
      
      const output = capture.stop();
      expect(output.stdout).toContain('created');
      expect(output.stdout).toContain('feature');
    });

    test('produces correct error output', async () => {
      mocks.gitOps.createWorktree.mockRejectedValue(new Error('Test error'));
      
      const capture = new ConsoleCapture();
      capture.start();
      
      await createCommand('feature', {}, { ...mocks, output: console });
      
      const output = capture.stop();
      expect(output.stderr).toContain('error');
      expect(output.stderr).toContain('Test error');
    });
  });
});

// Example of testing with specific mock configurations
describe('create command with custom config', () => {
  test('uses custom worktree directory', async () => {
    const mocks = MockSetup.createMockEnvironment({
      config: {
        worktreeDir: 'custom-worktrees',
        mainBranch: 'master'
      }
    });
    
    const result = await createCommand('feature', {}, mocks);
    
    expect(mocks.gitOps.createWorktree).toHaveBeenCalledWith(
      'feature',
      expect.objectContaining({
        path: 'custom-worktrees/wt-feature',
        baseBranch: 'master'
      })
    );
  });

  test('respects custom port ranges', async () => {
    const mocks = MockSetup.createMockEnvironment({
      config: {
        ports: {
          vite: { start: 4000, end: 4099 },
          storybook: { start: 7000, end: 7099 }
        }
      }
    });
    
    mocks.portManager.findAvailablePort.mockImplementation((start) => 
      Promise.resolve(start)
    );
    
    const result = await createCommand('feature', {}, mocks);
    
    expect(result.success).toBe(true);
  });
});